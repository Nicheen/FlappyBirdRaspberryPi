-- Create the highscores table with UNIQUE constraint on user_id
-- This ensures each user can only have ONE entry
CREATE TABLE IF NOT EXISTS highscores (
    id BIGSERIAL PRIMARY KEY,
    user_id UUID NOT NULL UNIQUE REFERENCES auth.users(id) ON DELETE CASCADE,
    username TEXT NOT NULL,
    score INTEGER NOT NULL CHECK (score >= 0),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Create an index on score for faster leaderboard queries
CREATE INDEX IF NOT EXISTS idx_highscores_score ON highscores(score DESC);

-- Create an index on updated_at for recently updated scores
CREATE INDEX IF NOT EXISTS idx_highscores_updated_at ON highscores(updated_at DESC);

-- Enable Row Level Security (RLS)
ALTER TABLE highscores ENABLE ROW LEVEL SECURITY;

-- Policy: Users can view all highscores (public leaderboard)
CREATE POLICY "Anyone can view highscores"
    ON highscores
    FOR SELECT
    USING (true);

-- Policy: Authenticated users can insert their own scores
CREATE POLICY "Authenticated users can insert their own scores"
    ON highscores
    FOR INSERT
    TO authenticated
    WITH CHECK (auth.uid() = user_id);

-- Policy: Users can update only their own scores
CREATE POLICY "Users can update their own scores"
    ON highscores
    FOR UPDATE
    TO authenticated
    USING (auth.uid() = user_id)
    WITH CHECK (auth.uid() = user_id);

-- Policy: Users can delete their own scores (optional)
CREATE POLICY "Users can delete their own scores"
    ON highscores
    FOR DELETE
    TO authenticated
    USING (auth.uid() = user_id);

-- Create a function to automatically update the updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create a trigger to automatically update updated_at on score changes
CREATE TRIGGER update_highscores_updated_at
    BEFORE UPDATE ON highscores
    FOR EACH ROW
    EXECUTE FUNCTION update_updated_at_column();
